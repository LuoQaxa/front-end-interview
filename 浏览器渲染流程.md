dns解析 ——> tcp连接(三次握手) -> http请求和响应 -> 服务器响应 -> 客户端渲染

[浏览器渲染页面过程与页面优化](https://segmentfault.com/a/1190000010298038)
绘制时间

paint flashing: 重绘的区域
页面滚动 互动操作 动画 css伪类 用户交互 内容变化输入框 样式变化

优化：
[滚动时禁用hover](https://segmentfault.com/q/1010000004103018?sort=created)
1. 同时避免组合触发 滚动的时候 关闭模块的hover效果，然后设定一个计时器，时间到了再把hover打开，滚动时不去执行昂贵的互动事件重绘。

layer borders： 显示层的组合边界
dom元素最终如何转变为屏幕上的可视图像？
1. 获取dom并将其分为多个层

fps meter 显示fps桢平

#### performance


浏览器内核：渲染引擎和js引擎，不同的渲染引擎在不同的浏览器表现不同，主要是讲chrome的webkit

1. html parse ——》 dom tree，但是这个过程不是一个完全顺畅的过程
2. css parse ——》css rule tree
3. dom tree 和 css rule tree ——》 render tree

构建dom：
网路传输的是字节数据 ——》 字符串 ——》 token ——》 node——》 dom
构建cssom
浏览器确定每一个节点的样式是怎么样的，但是这一个过程很消耗自由，因为样式既可以是继承也可以是自定义，所以需要递归cssom树才能具体确定元素是什么样式的
**CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。**
构建渲染树
**渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。**
布局和绘制：
当浏览器生产渲染树之后，就会根据渲染树来进行布局（回流）。 浏览器需要弄清楚各个节点在页面中的确切的位置和大小，这一行为也是**自动重排**
布局流程的输出是一个盒模型，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都会转换为屏幕上的绝对像素。
布局完成后，浏览器会发出 **paint setup** 和 **paint** 事件

回流 重排：layout 为啥是回流不是布局吗为啥叫回流呢？ 根据render tree 根据当前的设备计算出真实的宽度和像素大小
重绘：painting
发生回流一定会触发重绘，重绘不一定会回流。那什么时候是只重绘的，而不回流，而什么时候是重绘但是回流了的




回流和重绘的不同？
回流：浏览器会决定每个节点的大小和具体位置
重绘：这是一个用像素填充的过程，在浏览器上真实的绘制出每一个元素

